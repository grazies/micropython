{
  "name": "Micropython",
  "tagline": "MicroPython - a lean and efficient Python implementation for microcontrollers and constrained systems",
  "body": "[![Build Status][travis-img]][travis-repo] [![Coverage Status][coveralls-img]][coveralls-repo]\r\n[travis-img]:  https://travis-ci.org/micropython/micropython.png?branch=master\r\n[travis-repo]: https://travis-ci.org/micropython/micropython\r\n[coveralls-img]:  https://coveralls.io/repos/micropython/micropython/badge.png?branch=master\r\n[coveralls-repo]: https://coveralls.io/r/micropython/micropython?branch=master\r\n\r\nThe MicroPython project\r\n=======================\r\n<p align=\"center\">\r\n  <img src=\"https://raw.githubusercontent.com/micropython/micropython/master/logo/upython-with-micro.jpg\" alt=\"MicroPython Logo\"/>\r\n</p>\r\n\r\nThis is the MicroPython project, which aims to put an implementation\r\nof Python 3.x on microcontrollers and small embedded systems.\r\nYou can find the official website at [micropython.org](http://www.micropython.org).\r\n\r\nWARNING: this project is in beta stage and is subject to changes of the\r\ncode-base, including project-wide name changes and API changes.\r\n\r\nMicroPython implements the entire Python 3.4 syntax (including exceptions,\r\n\"with\", \"yield from\", etc., and additionally \"async\" keyword from Python 3.5).\r\nThe following core datatypes are provided: str (including basic Unicode\r\nsupport), bytes, bytearray, tuple, list, dict, set, frozenset, array.array,\r\ncollections.namedtuple, classes and instances. Builtin modules include sys,\r\ntime, and struct.  Note that only subset of Python 3.4 functionality\r\nimplemented for the data types and modules.\r\n\r\nSee the repository www.github.com/micropython/pyboard for the Micro\r\nPython board, the officially supported reference electronic circuit board.\r\n\r\nMajor components in this repository:\r\n- py/ -- the core Python implementation, including compiler, runtime, and\r\n  core library.\r\n- unix/ -- a version of MicroPython that runs on Unix.\r\n- stmhal/ -- a version of MicroPython that runs on the MicroPython board\r\n  with an STM32F405RG (using ST's Cube HAL drivers).\r\n- minimal/ -- a minimal MicroPython port. Start with this if you want\r\n  to port MicroPython to another microcontroller.\r\n- tests/ -- test framework and test scripts.\r\n- docs/ -- user documentation in Sphinx reStructuredText format.\r\n\r\nAdditional components:\r\n- bare-arm/ -- a bare minimum version of MicroPython for ARM MCUs. Used\r\n  mostly to control code size.\r\n- teensy/ -- a version of MicroPython that runs on the Teensy 3.1\r\n  (preliminary but functional).\r\n- pic16bit/ -- a version of MicroPython for 16-bit PIC microcontrollers.\r\n- cc3200/ -- a version of MicroPython that runs on the CC3200 from TI.\r\n- esp8266/ -- an experimental port for ESP8266 WiFi modules.\r\n- tools/ -- various tools, including the pyboard.py module.\r\n- examples/ -- a few example Python scripts.\r\n\r\nThe subdirectories above may include READMEs with additional info.\r\n\r\n\"make\" is used to build the components, or \"gmake\" on BSD-based systems.\r\nYou will also need bash and Python (at least 2.7 or 3.3).\r\n\r\nThe Unix version\r\n----------------\r\n\r\nThe \"unix\" port requires a standard Unix environment with gcc and GNU make.\r\nx86 and x64 architectures are supported (i.e. x86 32- and 64-bit), as well\r\nas ARM and MIPS. Making full-featured port to another architecture requires\r\nwriting some assembly code for the exception handling and garbage collection.\r\nAlternatively, fallback implementation based on setjmp/longjmp can be used.\r\n\r\nTo build (see section below for required dependencies):\r\n\r\n    $ cd unix\r\n    $ make axtls\r\n    $ make\r\n\r\nThen to give it a try:\r\n\r\n    $ ./micropython\r\n    >>> list(5 * x + y for x in range(10) for y in [4, 2, 1])\r\n\r\nUse `CTRL-D` (i.e. EOF) to exit the shell.\r\nLearn about command-line options (in particular, how to increase heap size\r\nwhich may be needed for larger applications):\r\n\r\n    $ ./micropython --help\r\n\r\nRun complete testsuite:\r\n\r\n    $ make test\r\n\r\nUnix version comes with a builtin package manager called upip, e.g.:\r\n\r\n    $ ./micropython -m upip install micropython-pystone\r\n    $ ./micropython -m pystone\r\n\r\nBrowse available modules on\r\n[PyPI](https://pypi.python.org/pypi?%3Aaction=search&term=micropython).\r\nStandard library modules come from\r\n[micropython-lib](https://github.com/micropython/micropython-lib) project.\r\n\r\nExternal dependencies\r\n---------------------\r\n\r\nBuilding Unix version requires some dependencies installed. For\r\nDebian/Ubuntu/Mint derivative Linux distros, install `build-essential`\r\n(includes toolchain and make), `libffi-dev`, and `pkg-config` packages.\r\n\r\nOther dependencies can be built together with MicroPython. Oftentimes,\r\nyou need to do this to enable extra features or capabilities. To build\r\nthese additional dependencies, first fetch git submodules for them:\r\n\r\n    $ git submodule update --init\r\n\r\nUse this same command to get the latest versions of dependencies, as\r\nthey are updated from time to time. After that, in `unix/` dir, execute:\r\n\r\n    $ make deplibs\r\n\r\nThis will build all available dependencies (regardless whether they\r\nare used or not). If you intend to build MicroPython with additional\r\noptions (like cross-compiling), the same set of options should be passed\r\nto `make deplibs`. To actually enabled use of dependencies, edit\r\n`unix/mpconfigport.mk` file, which has inline descriptions of the options.\r\nFor example, to build SSL module (required for `upip` tool described above),\r\nset `MICROPY_PY_USSL` to 1.\r\n\r\nIn `unix/mpconfigport.mk`, you can also disable some dependencies enabled\r\nby default, like FFI support, which requires libffi development files to\r\nbe installed.\r\n\r\nThe STM version\r\n---------------\r\n\r\nThe \"stmhal\" port requires an ARM compiler, arm-none-eabi-gcc, and associated\r\nbin-utils.  For those using Arch Linux, you need arm-none-eabi-binutils and\r\narm-none-eabi-gcc packages.  Otherwise, try here:\r\nhttps://launchpad.net/gcc-arm-embedded\r\n\r\nTo build:\r\n\r\n    $ cd stmhal\r\n    $ make\r\n\r\nYou then need to get your board into DFU mode.  On the pyboard, connect the\r\n3V3 pin to the P1/DFU pin with a wire (on PYBv1.0 they are next to each other\r\non the bottom left of the board, second row from the bottom).\r\n\r\nThen to flash the code via USB DFU to your device:\r\n\r\n    $ make deploy\r\n\r\nThis will use the included `tools/pydfu.py` script.  If flashing the firmware\r\ndoes not work it may be because you don't have the correct permissions, and\r\nneed to use `sudo make deploy`.\r\nSee the README.md file in the stmhal/ directory for further details.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}